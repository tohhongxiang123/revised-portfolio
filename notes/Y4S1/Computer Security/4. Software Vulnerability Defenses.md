# Software Vulnerability Defenses

# Safe Functions

Root cause: unsafe C lib functions have no range checking

-   `strcpy(char* dest, char* src)`
-   `strcat(char* dest, char* src)`
-   `gets(char* s)`

Solution: Use safe versions

-   `strncpy(char *dest, char *src, int n)`
    -   Copy `n` characters from `src` to `dest`
    -   Does not automatically add `NULL` to `dest` if `n` is less than length of string `src`
    -   Safer to always add `NULL` after `strncpy`
-   `strncat(char *dest, char *src, int n)`
-   `fgets(char *BUF, int N, FILE *FP)`

# Safe Libraries

`libsafe`

-   Check some common C functions
-   Examines current stack and frame pointers
-   Denies attempts to write data to stack that overwrites the return address or any parameters

`glib.h`

-   Provides Gstring type for dynamically growing null-terminated strings in C

`Strsafe.h`

-   New set of string-handling functions for C and C++
-   Guarantees null-termination and always takes destination size as argument

`SafeStr`

-   Provides new, high-level data type for strings and tracks accounting info for strings
-   Performs many other operations

`Glib`

-   Resizable and bounded

Apache portable Runtime (APR)

-   Resizable and bounded

# Safe Language

Use a strongly-typed language

-   Ada, Perl, Python etc. have automatic bounds checking, and no direct memory access
-   C-derivatives: Rust
    -   A safe, concurrent practical language which supports many functional and imperative procedural paradigms
    -   Does not permit null pointers, dangling pointers or race conditions
    -   Memory and other resources managed through Resource Acquisition Is Initialisation (RAII)
-   Go: type-safe, garbage-collected but C-looking language
    -   Good concurrency model for taking advantage of multi-core machines
    -   Appropriate for implementing server architectures

# Vulnerability Detection

-   Peer review
-   Code review checklist
    -   Wrong use of data: Variable not initialised, dangling pointers, index out of bounds etc
    -   Faults in declaration: Undeclared variable, variable declared twice
    -   Faults in computation: Division by zero, mixed type expressions
    -   Faults in relational expression: Incorrect boolean operators, wrong operator priorities
    -   Faults in control flow: Infinite loops, n + 1 errors

## Software Tests

Unit tests

-   Check to see if each piece of code behaves as expected in isolation
-   Unit tests should cover all code, including error handling

Regression tests

-   Check that old bugs haven't been reintroduced

Integration tests

-   Check that modules work together as expected

## Static Analysis

Analyse source code before running

-   Explore all possible execution paths with all possible inputs
-   Approximate all possible states
-   Limitations: Can introduce false positives

## Fuzzing

Find software bugs by feeding it random, corrupted or unexpected data

-   Random inputs explore a large part of the state space
-   Some unintended states are observable as crashes
-   Any crash is a bug, but only some bugs are exploitable

### Mutation-Based Fuzzing

1. Collect a corpus of inputs that explores as many states as possible
2. Perturb inputs randomly, possibly guided by heuristics
3. Run program on inputs, and check for crashes

Pros

-   Simple to setup
-   Use off-the-shelf software for many programs

Cons

-   Results depend on initial corpus quality
-   Coverage may be shallow

### Generation-Based Fuzzing

1. Convert a specification of the input format (RFC) into a generative procedure
2. Generate test cases according to procedure, and introduce random perturbations
3. Run program on inputs, and check for crashes

Pros:

-   Higher coverage by leveraging knowledge of input format

Cons

-   Requires a lot of effort to setup
-   Domain-specific

### Coverage-Guided Fuzzing

1. Using traditional fuzzing strategies to create new test cases by mutating the input
2. Test program and measure code coverage
3. Use code coverage as feedback to craft input for uncovered code

Pros

-   Good at finding new program states
-   Combines well with other fuzzing techniques

Cons

-   Cannot find all types of bugs

# Compiler Support

## StackGuard

Key idea: Difficult for attackers to only modify return address without overwriting stack memory in front of return address

Steps:

1. Embed a canary word next to the return address on the stack whenever a function is called
    - Value of canary has to be random, and cannot be guessed by attackers
2. When stack-buffer overflows into function return address, the canary is overwritten as well
3. Every time the function returns, check if canary value is modified
4. If so, stack-buffer overflow happened, and program is aborted

### Canary Types

Random canary

-   Choose random canary at startup
-   Insert canary string into every stack frame
-   Verify canary before exiting function
    -   If canary value is changed, then exit (potential Denial-of-Service attack)
-   To corrupt, attacker must learn current random string

Terminator canary

-   Canary = `{\0, newline, linefeed, EOF}`
-   String functions will not copy beyond terminator
-   Attacker cannot use string functions to corrupt stack

## Limitations of StackGuard

Efficiency

-   Program must be recompiled
-   Minimal performance effects

Canaries do not offer full-proof protection

-   Some stack smashing attacks leave canaries untouched

Hijacking function pointer

-   Even if attacker cannot overwrite return address due to canary, he can overwrite a function pointer

## PointGuard

Protect pointers from being overwritten

-   Encrypt all pointers in memory
    -   Generate random key when program is executed
    -   Each pointer is XORed with this key when stored into memory
-   Attackers cannot predict the target program's random key
    -   Even if pointer is overwritten, after XORing with the key, it will point to some random memory address
    -   This can prevent execution of malicious functions, but can crash the program (Denial-of-Service attack)
-   More noticeable performance overhead

## StackShield

A GNU C compiler extension that protects the return address

-   Separate control (return address) from data
    -   When a function is called, StackShield copies away the return address to a non overflowable area
    -   Upon returning from a function, the return address is stored
    -   Therefore, even if return address on the stack is altered, it has no effect since the original return address will be copied back before the return address is used to jump back

# OS Support

Software execution must follow a path of a Control Flow Graph (CFG) determined ahead of time

Direct jump

-   Destination address is constant, hence easy to check

Indirect jump

-   Destination address is determined at runtime, which cannot be predicted ahead of time
-   Prepare a set of predetermined destination addresses. At runtime, check if target address falls within this list
-   Cannot prevent attacks that causes a jump to a valid but incorrect address
-   Building CFG statically is hard

## Address Space Randomisation

ASLR

-   Attacker needs to get address of their injected code
-   OS can randomly arrange address space of key data areas for each program
-   Make it harder for attacker to get the address
-   Functions remain correct if stack and base pointers are setup correctly

## Non-Executable Memory

Mark all writeable memory locations as nonexecutable

-   Attackers can inject malicious code into memory and jump to it
-   Configure writable memory region to be non executable thus preventing malicious code to be executed
-   Windows: Data Execution Prevention
-   Linux: Execshield

Hardware support:

-   AMD64, Intel x86, ARM
-   Each page table entry has an attribute to control if the page is executable

## Limitations: JIT

2 types of executing programs

-   Compile a program to native binary code, then executes it on a machine (C)
-   Use an interpreter to interpret the source code and then execute (Python)

JIT compilation

-   Compile heavily used parts of the program, while interpret the rest
-   Exploit runtime profiling to perform more targeted optimisation than compilers targeting native code directly

Requires executable heap

-   Conflicts with non-executable memory protection

## Limitations: Code Reuse Attacks

Non executable memory protection does not work when the attacker does not inject malicious code into the stack. To compromise the program instead, we reuse the code in the program itself without injecting the code

Return-to-lib

-   Replace return address with address of dangerous library function
-   When function returns, dangerous library function executes
-   Can chain multiple library functions

## Shadow Stack

Keep a copy of the stack in memory

-   On call: Push return address to shadow stack
-   On return: Check that top of shadow stack is equal to return address on stack
-   If there is a difference, exit

## ARM Memory Tagging Extension

Tag the pointer and memory

-   Every 64 bit memory pointer $P$ has a 4-bit tag
-   Every 16-byte user memory region $R$ has a 4-bit tag
-   When $P$ reads $R$, processor checks the tags
    -   If match, allow access
    -   If not, hardware exception
